/*
 * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation;
 * version 2.1 of the License.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

package fi.vtt.noen.mfw.bundle.server.shared.datamodel;

import fi.vtt.noen.mfw.bundle.common.Const;
import fi.vtt.noen.mfw.bundle.common.Logger;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.Table;
import javax.persistence.Transient;
import java.util.Map;

/**
 * Describes a probe.
 * Annotations are for persistence with JPA (DB storage).
 *
 * @author Teemu Kanstren
 */
@Entity
@Table(name="probe_description")
public class ProbeDescription {
  private final static Logger log = new Logger(ProbeDescription.class);
  //unique identifier generated by the JPA persistence provider/DB storage.
  @GeneratedValue
  @Id
  @Column(name="id", nullable=false, updatable=false)
  private Long probeId;
  //the (XMLRPC) endpoint to reach this probe
  @Column(name="endpoint")
  private String endpoint;
  //measurement precision
  @Column(name="bm_precision")
  private int precision;
  //how much time has elapsed in milliseconds since the last time we heard a keep-alive message from this probe
  @Transient
  private int delay = 0;
  //name of the probe
  @Column(name="probe_name")
  private String probeName;
  //target of measurement (also embedded in BMdescription, so could be removed..)
  @ManyToOne(fetch= FetchType.EAGER)
  private TargetDescription target;
  //the base measure that the probe provides
  @ManyToOne(fetch= FetchType.EAGER)
  private BMDescription bm;

  public ProbeDescription() {
    resetDelay();
  }

  public ProbeDescription(Map<String, String> properties, TargetDescription target, BMDescription bm) {
    String probeUrl = properties.get(Const.XMLRPC_URL);
    setEndpoint(probeUrl);
    this.target = target;
    this.bm = bm;
    this.probeName = properties.get(Const.PROBE_NAME);
    this.precision = Integer.parseInt(properties.get(Const.PROBE_PRECISION));
    resetDelay();
  }

  //typically we do not change the probe endpoint address but when we read the existing data from the database,
  //we need to update the endpoint with the actual current endpoint that may wary. the basic scenario is the
  //change of the HTTP server port but other changes are also possible. Reading the values from the DB is needed
  //in order the ensure that the probe identifier numbers are persistent for the clients. The probe is identified
  //by its base measure, that is, the bm class, bm name, target type, target name = measureURI
  public void updateEndpoint(Map<String, String> properties) {
    String probeUrl = properties.get(Const.XMLRPC_URL);
    setEndpoint(probeUrl);
  }

  public long getProbeId() {
    return probeId;
  }

  public TargetDescription getTarget() {
    return target;
  }

  public void resetDelay() {
    delay = 0;
  }

  public String getEndpoint() {
    return endpoint;
  }

  public void setEndpoint(String probeUrl) {
    this.endpoint = probeUrl;
  }

  public String getMeasureURI() {
    return Const.createMeasureURI(target.getTargetType(), target.getTargetName(), bm.getBmClass(), bm.getBmName());
  }

  public int getPrecision() {
    return precision;
  }

  public int getDelay() {
    return delay;
  }

  public void increaseDelay(int increment) {
    this.delay += increment;
  }

  public String getProbeName() {
    return probeName;
  }

  public BMDescription getBm() {
    return bm;
  }

  public boolean matches(ProbeDescription probe) {
    if (getMeasureURI() != null ? !getMeasureURI().equals(probe.getMeasureURI()) : probe.getMeasureURI() != null)
      return false;

    return true;
  }

  //this provides a check if two probe descriptions are the same, for example, to avoid duplicate registrations after network cutoff
  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    ProbeDescription that = (ProbeDescription) o;
    int endIndex = endpoint.indexOf("/xmlrpc");
    String thisEndpoint = endpoint.substring(0, endIndex-4);
    String thatEndpoint = that.endpoint.substring(0, endIndex-4);

    if (precision != that.precision) return false;
    if (getBm() != null ? !getBm().equals(that.getBm()) : that.getBm() != null) return false;
    if (getMeasureURI() != null ? !getMeasureURI().equals(that.getMeasureURI()) : that.getMeasureURI() != null) return false;
    if (getTarget() != null ? !getTarget().equals(that.getTarget()) : that.getTarget() != null) return false;
    if (thisEndpoint != null ? !thisEndpoint.equals(thatEndpoint) : thatEndpoint != null) return false;
    if (probeName != null ? !probeName.equals(that.probeName) : that.probeName != null) return false;

    return true;
  }

  @Override
  public int hashCode() {
    int result = endpoint != null ? endpoint.hashCode() : 0;
    result = 31 * result + (getMeasureURI() != null ? getMeasureURI().hashCode() : 0);
    result = 31 * result + precision;
    result = 31 * result + (probeName != null ? probeName.hashCode() : 0);
    result = 31 * result + (bm != null ? bm.hashCode() : 0);
    return result;
  }

  @Override
  public String toString() {
    return "ProbeDescription{" +
            "endpoint='" + endpoint + '\'' +
            ", measureURI='" + getMeasureURI() + '\'' +
            ", precision=" + precision +
            ", probeId=" + probeId +
            ", delay=" + delay +
            ", name='" + probeName + '\'' +
            ", deviceName='" + target.getTargetName() + '\'' +
            ", deviceType='" + target.getTargetType() + '\'' +
            ", bmName='" + bm.getBmName() + '\'' +
            ", bmDescription='" + bm.getBmDescription() + '\'' +
            ", id='" + probeId + '\'' +
            '}';
  }
}
